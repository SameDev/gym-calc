<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plantas vs Zumbis com Fusão</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            background-color: #8bc34a;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #plantSelection {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        .plant-icon {
            width: 50px;
            height: 50px;
            background-color: #4CAF50;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            overflow: hidden;
        }
        .plant-icon img {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }
        .plant-icon:hover {
            background-color: #45a049;
        }
        #mergeArea {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 100px;
            background-color: rgba(255, 255, 0, 0.3);
            border: 2px dashed yellow;
            border-radius: 5px;
            display: none;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loading">Carregando recursos...</div>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>Sol: <span id="sunCount">100</span></div>
        <div>Zumbis: <span id="zombieCount">0</span></div>
    </div>
    <div id="plantSelection">
        <div class="plant-icon" data-plant="girasol" data-cost="50"><img src="https://i.imgur.com/JvQb2QJ.png" alt="Girasol"></div>
        <div class="plant-icon" data-plant="atiradora" data-cost="100"><img src="https://i.imgur.com/LkZ5vVp.png" alt="Atiradora"></div>
        <div class="plant-icon" data-plant="noz" data-cost="50"><img src="https://i.imgur.com/7WQnXzK.png" alt="Noz"></div>
    </div>
    <div id="mergeArea">Área de Fusão</div>

    <script>
        // Configurações do jogo
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Recursos do jogo (sprites)
        const sprites = {
            girasol: new Image(),
            atiradora: new Image(),
            atiradora2: new Image(),
            atiradora3: new Image(),
            noz: new Image(),
            zombie: new Image(),
            projectile: new Image(),
            sun: new Image()
        };

        // URLs dos sprites (substitua por seus próprios URLs) - deepseek
        sprites.girasol.src = 'https://i.imgur.com/5SixOo8.png';
        sprites.atiradora.src = 'https://i.imgur.com/5SixOo8.png';
        sprites.atiradora2.src = 'https://i.imgur.com/5SixOo8.png';
        sprites.atiradora3.src = 'https://i.imgur.com/5SixOo8.png';
        sprites.noz.src = 'https://i.imgur.com/5SixOo8.png';
        sprites.zombie.src = 'https://i.imgur.com/5SixOo8.png';
        sprites.projectile.src = 'https://i.imgur.com/5SixOo8.png';
        sprites.sun.src = 'https://i.imgur.com/5SixOo8.png';

        // Estado do jogo
        const gameState = {
            sun: 100,
            plants: [],
            zombies: [],
            projectiles: [],
            selectedPlant: null,
            draggingPlant: null,
            mergePlants: [],
            lastZombieTime: 0,
            zombieInterval: 5000,
            lastSunTime: 0,
            sunInterval: 5000,
            grid: {
                rows: 5,
                cols: 9,
                cellWidth: 80,
                cellHeight: 100,
                offsetX: 100,
                offsetY: 100
            },
            assetsLoaded: 0,
            totalAssets: Object.keys(sprites).length
        };

        // Plantas disponíveis
        const plantTypes = {
            girasol: {
                sprite: sprites.girasol,
                cost: 50,
                health: 100,
                recharge: 10,
                sunProduction: 25,
                sunProductionTime: 10000,
                color: '#FFD700',
                width: 50,
                height: 50
            },
            atiradora: {
                sprite: sprites.atiradora,
                cost: 100,
                health: 150,
                recharge: 5,
                damage: 20,
                range: 300,
                attackSpeed: 2000,
                color: '#4CAF50',
                width: 50,
                height: 50
            },
            noz: {
                sprite: sprites.noz,
                cost: 50,
                health: 400,
                recharge: 20,
                color: '#8B4513',
                width: 50,
                height: 50
            },
            atiradora2: { // Planta fundida nível 1
                sprite: sprites.atiradora2,
                cost: 0,
                health: 200,
                recharge: 3,
                damage: 30,
                range: 350,
                attackSpeed: 1500,
                color: '#2E8B57',
                width: 50,
                height: 50
            },
            atiradora3: { // Planta fundida nível 2
                sprite: sprites.atiradora3,
                cost: 0,
                health: 300,
                recharge: 2,
                damage: 50,
                range: 400,
                attackSpeed: 1000,
                color: '#006400',
                width: 50,
                height: 50
            }
        };

        // Verifica se todos os assets foram carregados
        function checkAssetsLoaded() {
            gameState.assetsLoaded++;
            if (gameState.assetsLoaded === gameState.totalAssets) {
                document.getElementById('loading').style.display = 'none';
                updateUI();
                requestAnimationFrame(gameLoop);
            }
        }

        // Configura os event listeners para os sprites
        Object.values(sprites).forEach(sprite => {
            sprite.onload = checkAssetsLoaded;
            sprite.onerror = () => {
                console.error('Erro ao carregar sprite:', sprite.src);
                checkAssetsLoaded();
            };
        });

        // Atualiza a UI
        function updateUI() {
            document.getElementById('sunCount').textContent = gameState.sun;
            document.getElementById('zombieCount').textContent = gameState.zombies.length;
        }

        // Desenha a grade
        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            
            for (let row = 0; row < gameState.grid.rows; row++) {
                for (let col = 0; col < gameState.grid.cols; col++) {
                    const x = gameState.grid.offsetX + col * gameState.grid.cellWidth;
                    const y = gameState.grid.offsetY + row * gameState.grid.cellHeight;
                    
                    ctx.strokeRect(x, y, gameState.grid.cellWidth, gameState.grid.cellHeight);
                }
            }
        }

        // Obtém a posição da grade a partir de coordenadas
        function getGridPosition(x, y) {
            const col = Math.floor((x - gameState.grid.offsetX) / gameState.grid.cellWidth);
            const row = Math.floor((y - gameState.grid.offsetY) / gameState.grid.cellHeight);
            
            if (row >= 0 && row < gameState.grid.rows && col >= 0 && col < gameState.grid.cols) {
                return {
                    row,
                    col,
                    x: gameState.grid.offsetX + col * gameState.grid.cellWidth,
                    y: gameState.grid.offsetY + row * gameState.grid.cellHeight
                };
            }
            return null;
        }

        // Verifica se uma posição na grade está ocupada
        function isGridPositionOccupied(row, col) {
            return gameState.plants.some(plant => plant.row === row && plant.col === col);
        }

        // Adiciona uma planta
        function addPlant(type, row, col) {
            const plant = {
                type,
                row,
                col,
                health: plantTypes[type].health,
                lastActionTime: 0,
                ...plantTypes[type]
            };
            
            gameState.plants.push(plant);
            return plant;
        }

        // Desenha as plantas
        function drawPlants() {
            gameState.plants.forEach(plant => {
                const x = gameState.grid.offsetX + plant.col * gameState.grid.cellWidth + gameState.grid.cellWidth / 2;
                const y = gameState.grid.offsetY + plant.row * gameState.grid.cellHeight + gameState.grid.cellHeight / 2;
                
                // Desenha o sprite da planta
                if (plant.sprite.complete) {
                    ctx.drawImage(
                        plant.sprite,
                        x - plant.width / 2,
                        y - plant.height / 2,
                        plant.width,
                        plant.height
                    );
                } else {
                    // Fallback caso o sprite não tenha carregado
                    ctx.fillStyle = plant.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Barra de saúde
                const healthPercent = plant.health / plantTypes[plant.type].health;
                ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.2 ? '#FFC107' : '#F44336';
                ctx.fillRect(
                    x - 25, 
                    y + 35, 
                    50 * healthPercent, 
                    5
                );
            });
        }

        // Atualiza as plantas
        function updatePlants(timestamp) {
            gameState.plants.forEach(plant => {
                // Produção de sol para girasóis
                if (plant.type === 'girasol' && timestamp - plant.lastActionTime > plant.sunProductionTime) {
                    gameState.sun += plant.sunProduction;
                    plant.lastActionTime = timestamp;
                    updateUI();
                }
                
                // Ataque para plantas atiradoras
                if (plant.type.includes('atiradora') && timestamp - plant.lastActionTime > plant.attackSpeed) {
                    const zombieInRow = gameState.zombies.find(zombie => zombie.row === plant.row && zombie.x > plant.col * gameState.grid.cellWidth);
                    if (zombieInRow) {
                        const projectile = {
                            x: gameState.grid.offsetX + plant.col * gameState.grid.cellWidth + gameState.grid.cellWidth / 2,
                            y: gameState.grid.offsetY + plant.row * gameState.grid.cellHeight + gameState.grid.cellHeight / 2,
                            targetX: zombieInRow.x,
                            targetY: gameState.grid.offsetY + zombieInRow.row * gameState.grid.cellHeight + gameState.grid.cellHeight / 2,
                            damage: plant.damage,
                            speed: 5,
                            reached: false,
                            width: 20,
                            height: 20
                        };
                        gameState.projectiles.push(projectile);
                        plant.lastActionTime = timestamp;
                    }
                }
            });
        }

        // Desenha os projéteis
        function drawProjectiles() {
            gameState.projectiles.forEach(proj => {
                if (sprites.projectile.complete) {
                    ctx.drawImage(
                        sprites.projectile,
                        proj.x - proj.width / 2,
                        proj.y - proj.height / 2,
                        proj.width,
                        proj.height
                    );
                } else {
                    // Fallback
                    ctx.fillStyle = '#FF5722';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // Atualiza os projéteis
        function updateProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                // Move o projétil
                const dx = proj.targetX - proj.x;
                const dy = proj.targetY - proj.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < proj.speed) {
                    proj.reached = true;
                    
                    // Encontra o zumbi mais próximo para causar dano
                    const zombie = gameState.zombies.find(z => {
                        const zx = z.x;
                        const zy = gameState.grid.offsetY + z.row * gameState.grid.cellHeight + gameState.grid.cellHeight / 2;
                        const dist = Math.sqrt(Math.pow(proj.targetX - zx, 2) + Math.pow(proj.targetY - zy, 2));
                        return dist < 30;
                    });
                    
                    if (zombie) {
                        zombie.health -= proj.damage;
                        if (zombie.health <= 0) {
                            gameState.zombies.splice(gameState.zombies.indexOf(zombie), 1);
                            updateUI();
                        }
                    }
                } else {
                    proj.x += (dx / distance) * proj.speed;
                    proj.y += (dy / distance) * proj.speed;
                }
                
                // Remove projéteis que atingiram o alvo
                if (proj.reached) {
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        // Adiciona um zumbi
        function addZombie(row) {
            const zombie = {
                row,
                x: canvas.width,
                health: 100,
                speed: 0.5,
                damage: 0.5,
                width: 40,
                height: 80
            };
            
            gameState.zombies.push(zombie);
            updateUI();
            return zombie;
        }

        // Desenha os zumbis
        function drawZombies() {
            gameState.zombies.forEach(zombie => {
                const y = gameState.grid.offsetY + zombie.row * gameState.grid.cellHeight + gameState.grid.cellHeight / 2;
                
                if (sprites.zombie.complete) {
                    ctx.drawImage(
                        sprites.zombie,
                        zombie.x - zombie.width / 2,
                        y - zombie.height / 2,
                        zombie.width,
                        zombie.height
                    );
                } else {
                    // Fallback
                    ctx.fillStyle = '#607D8B';
                    // Corpo
                    ctx.beginPath();
                    ctx.arc(zombie.x, y, 20, 0, Math.PI * 2);
                    ctx.fill();
                    // Cabeça
                    ctx.beginPath();
                    ctx.arc(zombie.x, y - 25, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Barra de saúde
                const healthPercent = zombie.health / 100;
                ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.2 ? '#FFC107' : '#F44336';
                ctx.fillRect(
                    zombie.x - 20, 
                    y - zombie.height / 2 - 10, 
                    40 * healthPercent, 
                    5
                );
            });
        }

        // Atualiza os zumbis
        function updateZombies() {
            gameState.zombies.forEach(zombie => {
                // Move o zumbi
                zombie.x -= zombie.speed;
                
                // Verifica colisão com plantas
                const gridPos = getGridPosition(zombie.x, gameState.grid.offsetY + zombie.row * gameState.grid.cellHeight);
                if (gridPos) {
                    const plant = gameState.plants.find(p => p.row === gridPos.row && p.col === gridPos.col);
                    if (plant) {
                        plant.health -= zombie.damage;
                        if (plant.health <= 0) {
                            gameState.plants.splice(gameState.plants.indexOf(plant), 1);
                        }
                    }
                }
                
                // Verifica se chegou ao final (casa)
                if (zombie.x < gameState.grid.offsetX) {
                    alert('Game Over! Os zumbis invadiram sua casa!');
                    resetGame();
                }
            });
        }

        // Gera sol automático
        function generateSun(timestamp) {
            if (timestamp - gameState.lastSunTime > gameState.sunInterval) {
                gameState.sun += 25;
                gameState.lastSunTime = timestamp;
                updateUI();
            }
        }

        // Gera zumbis
        function generateZombies(timestamp) {
            if (timestamp - gameState.lastZombieTime > gameState.zombieInterval) {
                const row = Math.floor(Math.random() * gameState.grid.rows);
                addZombie(row);
                gameState.lastZombieTime = timestamp;
                
                // Aumenta a dificuldade diminuindo o intervalo
                gameState.zombieInterval = Math.max(1000, gameState.zombieInterval - 100);
            }
        }

        // Função para fundir plantas
        function mergePlants() {
            const mergeArea = document.getElementById('mergeArea');
            
            if (gameState.mergePlants.length === 2) {
                const plant1 = gameState.mergePlants[0];
                const plant2 = gameState.mergePlants[1];
                
                // Verifica se são do mesmo tipo
                if (plant1.type === plant2.type) {
                    // Remove as plantas antigas
                    gameState.plants.splice(gameState.plants.indexOf(plant1), 1);
                    gameState.plants.splice(gameState.plants.indexOf(plant2), 1);
                    
                    // Cria uma nova planta fundida
                    let newType;
                    if (plant1.type === 'atiradora') {
                        newType = 'atiradora2';
                    } else if (plant1.type === 'atiradora2') {
                        newType = 'atiradora3';
                    } else {
                        // Para outros tipos, apenas melhora a planta
                        newType = plant1.type;
                    }
                    
                    // Adiciona a nova planta no centro da área de fusão
                    const rect = mergeArea.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const gridPos = getGridPosition(centerX, centerY);
                    
                    if (gridPos && !isGridPositionOccupied(gridPos.row, gridPos.col)) {
                        addPlant(newType, gridPos.row, gridPos.col);
                    } else {
                        // Se não houver espaço, coloca na primeira posição disponível
                        for (let row = 0; row < gameState.grid.rows; row++) {
                            for (let col = 0; col < gameState.grid.cols; col++) {
                                if (!isGridPositionOccupied(row, col)) {
                                    addPlant(newType, row, col);
                                    return;
                                }
                            }
                        }
                    }
                }
            }
            
            // Limpa a área de fusão
            gameState.mergePlants = [];
            mergeArea.style.display = 'none';
        }

        // Reinicia o jogo
        function resetGame() {
            gameState.sun = 100;
            gameState.plants = [];
            gameState.zombies = [];
            gameState.projectiles = [];
            gameState.lastZombieTime = 0;
            gameState.zombieInterval = 5000;
            updateUI();
        }

        // Loop do jogo
        function gameLoop(timestamp) {
            // Limpa o canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Desenha a grade
            drawGrid();
            
            // Atualiza e desenha elementos do jogo
            updatePlants(timestamp);
            drawPlants();
            
            updateProjectiles();
            drawProjectiles();
            
            updateZombies();
            drawZombies();
            
            // Gera recursos e inimigos
            generateSun(timestamp);
            generateZombies(timestamp);
            
            // Continua o loop
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.querySelectorAll('.plant-icon').forEach(icon => {
            icon.addEventListener('mousedown', (e) => {
                const plantType = e.currentTarget.getAttribute('data-plant');
                const cost = parseInt(e.currentTarget.getAttribute('data-cost'));
                
                if (gameState.sun >= cost) {
                    gameState.draggingPlant = {
                        type: plantType,
                        cost: cost,
                        element: e.currentTarget
                    };
                    e.currentTarget.style.opacity = '0.5';
                }
            });
        });

        document.addEventListener('mouseup', (e) => {
            if (gameState.draggingPlant) {
                gameState.draggingPlant.element.style.opacity = '1';
                
                const gridPos = getGridPosition(e.clientX, e.clientY);
                if (gridPos && !isGridPositionOccupied(gridPos.row, gridPos.col)) {
                    gameState.sun -= gameState.draggingPlant.cost;
                    addPlant(gameState.draggingPlant.type, gridPos.row, gridPos.col);
                    updateUI();
                }
                
                gameState.draggingPlant = null;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (gameState.draggingPlant) {
                // Você pode adicionar um efeito visual de arrastar aqui se quiser
            }
        });

        // Eventos para fusão de plantas
        document.addEventListener('keydown', (e) => {
            if (e.key === 'm') {
                const mergeArea = document.getElementById('mergeArea');
                mergeArea.style.display = 'flex';
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'm') {
                mergePlants();
            }
        });

        canvas.addEventListener('click', (e) => {
            const mergeArea = document.getElementById('mergeArea');
            if (mergeArea.style.display === 'flex') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Verifica se clicou em uma planta
                gameState.plants.forEach(plant => {
                    const plantX = gameState.grid.offsetX + plant.col * gameState.grid.cellWidth + gameState.grid.cellWidth / 2;
                    const plantY = gameState.grid.offsetY + plant.row * gameState.grid.cellHeight + gameState.grid.cellHeight / 2;
                    const distance = Math.sqrt(Math.pow(x - plantX, 2) + Math.pow(y - plantY, 2));
                    
                    if (distance < 30 && gameState.mergePlants.length < 2 && !gameState.mergePlants.includes(plant)) {
                        gameState.mergePlants.push(plant);
                        
                        // Destaque visual
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                        ctx.beginPath();
                        ctx.arc(plantX, plantY, 35, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
        });

        // Redimensionamento da janela
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Inicia o jogo após carregar os assets
        // (O loop do jogo é iniciado pela função checkAssetsLoaded)
        updateUI();
        drawGrid();
    </script>
</body>
</html>